name: Deploy to Server

on:
    push:
        branches:
            - "master"
            - "deployment-fix"
    pull_request:
        branches:
            - "master"

permissions:
    contents: read

concurrency:
    group: deploy-calc-stack
    cancel-in-progress: true

defaults:
    run:
        shell: "bash -euo pipefail {0}"

jobs:
    deploy:
        runs-on: self-hosted
        env:
            APP_PATH: /opt/calc_app
            STACK_NAME: calc_stack
            IMAGE_NAME: loan-calc-app
            IMAGE_TAG: latest

        steps:
            - name: Checkout
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Choose deploy context (APP_PATH or workspace)
              id: ctx
              run: |
                  TARGET="${APP_PATH}"
                  if mkdir -p "${TARGET}" 2>/dev/null; then
                    echo "Using APP_PATH=${TARGET}"
                    echo "CTX=${TARGET}" >> "$GITHUB_ENV"
                  else
                    echo "WARNING: ${TARGET} not usable; falling back to workspace"
                    echo "CTX=${{ github.workspace }}" >> "$GITHUB_ENV"
                  fi

            - name: Sync source to context (only if context != workspace)
              run: |
                  echo "CTX is: ${CTX}"
                  if [ "${CTX}" != "${{ github.workspace }}" ]; then
                    echo "Syncing repo into ${CTX}"
                    # one-time cleanup of any stray .git
                    rm -rf "${CTX}/.git" || true
                    rsync -a --delete --delete-excluded \
                      --exclude '.git' \
                      "${{ github.workspace }}/" "${CTX}/"
                  else
                    echo "CTX equals workspace; skipping rsync"
                  fi

            - name: Verify context contents
              run: |
                  echo "Listing CTX=${CTX}"
                  ls -la "${CTX}"
                  echo "Dockerfile size:"
                  wc -c "${CTX}/Dockerfile" || true
                  echo "docker-compose.yml size:"
                  wc -c "${CTX}/docker-compose.yml" || true

            - name: Build image (tags as :latest to match compose)
              run: |
                  # Use ABSOLUTE paths to avoid snap /var/lib/snapd/void issues
                  if [ ! -f "${CTX}/Dockerfile" ]; then
                    echo "ERROR: ${CTX}/Dockerfile not found"; exit 1
                  fi
                  docker build --pull \
                    -f "${CTX}/Dockerfile" \
                    -t "${IMAGE_NAME}:${IMAGE_TAG}" \
                    "${CTX}"

            - name: Render compose with absolute paths
              run: |
                  if [ ! -f "${CTX}/docker-compose.yml" ]; then
                    echo "ERROR: ${CTX}/docker-compose.yml not found"; exit 1
                  fi
                  docker compose \
                    --project-directory "${CTX}" \
                    -f "${CTX}/docker-compose.yml" \
                    config > /tmp/stack.rendered.yml
                  echo "Rendered compose to /tmp/stack.rendered.yml"
                  head -n 50 /tmp/stack.rendered.yml || true

            - name: Deploy to Swarm (only on push)
              if: github.event_name == 'push'
              run: |
                  docker stack deploy --prune -c /tmp/stack.rendered.yml "${STACK_NAME}"

            - name: Verify rollout (only on push)
              if: github.event_name == 'push'
              run: |
                  echo "Services:"
                  docker stack services "${STACK_NAME}"
                  echo
                  for svc in $(docker stack services --format '{{.Name}}' "${STACK_NAME}"); do
                    echo "---- $svc ----"
                    docker service ps --no-trunc --limit 20 "$svc" || true
                  done

            - name: Cleanup dangling images
              run: |
                  docker image prune -f || true
